/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["health.ping"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["workspaces.list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["nodes.search"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["nodes.read"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["nodes.getChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.updateTags"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/fields/{attributeId}/option": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.setFieldOption"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/fields/{attributeId}/content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.setFieldContent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{parentNodeId}/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.importTanaPaste"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/trash": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.trash"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/done": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.setDone"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["nodes.update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["tags.list"];
        put?: never;
        post: operations["tags.create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{tagId}/schema": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["tags.getSchema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{tagId}/fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["tags.addField"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{tagId}/checkbox": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["tags.setCheckbox"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaces/{workspaceId}/calendar/node": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["calendar.getNodeId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: never;
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "health.ping": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @enum {unknown} */
                        status: "ok" | "degraded";
                        timestamp: string;
                        nodeSpaceReady: boolean;
                    };
                };
            };
        };
    };
    "workspaces.list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        id: string;
                        name: string;
                        homeNodeId: string;
                    }[];
                };
            };
        };
    };
    "nodes.search": {
        parameters: {
            query: {
                query: {
                    /** @description All conditions must match */
                    and?: {
                        /** @description All conditions must match */
                        and?: unknown[];
                        /** @description At least one condition must match */
                        or?: unknown[];
                        /** @description Condition must NOT match */
                        not?: unknown;
                        /** @description Find nodes with a specific type/tag */
                        hasType?: string | {
                            /** @description Type ID to search for */
                            typeId: string;
                            /** @description Include nodes with types that extend this type (default: true) */
                            includeExtensions?: boolean;
                        };
                        /** @description Match nodes by field values */
                        field?: {
                            /** @description Field/attribute ID to match */
                            fieldId: string;
                            /** @description Match field that references this specific node ID */
                            nodeId?: string;
                            /** @description Match field with this exact string value (case-insensitive) */
                            stringValue?: string;
                            /** @description Match field with this exact numeric value */
                            numberValue?: number;
                            /**
                             * @description Field presence state: defined/undefined/set/notSet
                             * @enum {unknown}
                             */
                            state?: "defined" | "undefined" | "set" | "notSet";
                        };
                        /** @description Compare field values */
                        compare?: {
                            /** @description Field/attribute ID to compare */
                            fieldId: string;
                            /**
                             * @description Comparison operator: gt (>), lt (<), eq (=)
                             * @enum {unknown}
                             */
                            operator: "gt" | "lt" | "eq";
                            /** @description Value to compare against */
                            value: string | number;
                            /**
                             * @description Type of comparison
                             * @enum {unknown}
                             */
                            type: "number" | "date" | "string";
                        };
                        /** @description Case-insensitive substring match in node names */
                        textContains?: string;
                        /** @description Regular expression pattern in /pattern/ or /pattern/i format */
                        textMatches?: string;
                        /** @description Find children of specified nodes */
                        childOf?: {
                            /** @description Parent node IDs */
                            nodeIds: string[];
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include referenced nodes (default: true) */
                            includeRefs?: boolean;
                        };
                        /** @description Find nodes owned by a specific node */
                        ownedBy?: {
                            /** @description Owner node ID */
                            nodeId: string;
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include the owner node itself (default: false) */
                            includeSelf?: boolean;
                        };
                        /** @description Find nodes that link to these IDs */
                        linksTo?: string[];
                        /**
                         * @description Special node type filter
                         * @enum {unknown}
                         */
                        is?: "done" | "todo" | "template" | "field" | "published" | "entity" | "calendarNode" | "onDayNode" | "chat" | "search" | "command" | "inLibrary";
                        /**
                         * @description Find nodes that have specific content
                         * @enum {unknown}
                         */
                        has?: "tag" | "field" | "media" | "audio" | "video" | "image";
                        /** @description Find nodes created within N days */
                        created?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes edited within time range */
                        edited?: {
                            /**
                             * Format: email
                             * @description User email to filter by
                             */
                            by?: string;
                            /** @description Number of days */
                            last?: number;
                            /** @description Milliseconds timestamp */
                            since?: number;
                        };
                        /** @description Find nodes marked done within N days */
                        done?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes with matching dates */
                        onDate?: string | {
                            /** @description ISO date string */
                            date: string;
                            /** @description Specific field to check */
                            fieldId?: string;
                            /** @description Check if date ranges overlap */
                            overlaps?: boolean;
                        };
                        /** @description Limit to specific workspace ID */
                        inWorkspace?: string;
                        /**
                         * @description Find tasks with due dates in the past
                         * @constant
                         */
                        overdue?: true;
                        /**
                         * @description Find nodes in the library/stash
                         * @constant
                         */
                        inLibrary?: true;
                    }[];
                    /** @description At least one condition must match */
                    or?: {
                        /** @description All conditions must match */
                        and?: unknown[];
                        /** @description At least one condition must match */
                        or?: unknown[];
                        /** @description Condition must NOT match */
                        not?: unknown;
                        /** @description Find nodes with a specific type/tag */
                        hasType?: string | {
                            /** @description Type ID to search for */
                            typeId: string;
                            /** @description Include nodes with types that extend this type (default: true) */
                            includeExtensions?: boolean;
                        };
                        /** @description Match nodes by field values */
                        field?: {
                            /** @description Field/attribute ID to match */
                            fieldId: string;
                            /** @description Match field that references this specific node ID */
                            nodeId?: string;
                            /** @description Match field with this exact string value (case-insensitive) */
                            stringValue?: string;
                            /** @description Match field with this exact numeric value */
                            numberValue?: number;
                            /**
                             * @description Field presence state: defined/undefined/set/notSet
                             * @enum {unknown}
                             */
                            state?: "defined" | "undefined" | "set" | "notSet";
                        };
                        /** @description Compare field values */
                        compare?: {
                            /** @description Field/attribute ID to compare */
                            fieldId: string;
                            /**
                             * @description Comparison operator: gt (>), lt (<), eq (=)
                             * @enum {unknown}
                             */
                            operator: "gt" | "lt" | "eq";
                            /** @description Value to compare against */
                            value: string | number;
                            /**
                             * @description Type of comparison
                             * @enum {unknown}
                             */
                            type: "number" | "date" | "string";
                        };
                        /** @description Case-insensitive substring match in node names */
                        textContains?: string;
                        /** @description Regular expression pattern in /pattern/ or /pattern/i format */
                        textMatches?: string;
                        /** @description Find children of specified nodes */
                        childOf?: {
                            /** @description Parent node IDs */
                            nodeIds: string[];
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include referenced nodes (default: true) */
                            includeRefs?: boolean;
                        };
                        /** @description Find nodes owned by a specific node */
                        ownedBy?: {
                            /** @description Owner node ID */
                            nodeId: string;
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include the owner node itself (default: false) */
                            includeSelf?: boolean;
                        };
                        /** @description Find nodes that link to these IDs */
                        linksTo?: string[];
                        /**
                         * @description Special node type filter
                         * @enum {unknown}
                         */
                        is?: "done" | "todo" | "template" | "field" | "published" | "entity" | "calendarNode" | "onDayNode" | "chat" | "search" | "command" | "inLibrary";
                        /**
                         * @description Find nodes that have specific content
                         * @enum {unknown}
                         */
                        has?: "tag" | "field" | "media" | "audio" | "video" | "image";
                        /** @description Find nodes created within N days */
                        created?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes edited within time range */
                        edited?: {
                            /**
                             * Format: email
                             * @description User email to filter by
                             */
                            by?: string;
                            /** @description Number of days */
                            last?: number;
                            /** @description Milliseconds timestamp */
                            since?: number;
                        };
                        /** @description Find nodes marked done within N days */
                        done?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes with matching dates */
                        onDate?: string | {
                            /** @description ISO date string */
                            date: string;
                            /** @description Specific field to check */
                            fieldId?: string;
                            /** @description Check if date ranges overlap */
                            overlaps?: boolean;
                        };
                        /** @description Limit to specific workspace ID */
                        inWorkspace?: string;
                        /**
                         * @description Find tasks with due dates in the past
                         * @constant
                         */
                        overdue?: true;
                        /**
                         * @description Find nodes in the library/stash
                         * @constant
                         */
                        inLibrary?: true;
                    }[];
                    /** @description Condition must NOT match */
                    not?: {
                        /** @description All conditions must match */
                        and?: unknown[];
                        /** @description At least one condition must match */
                        or?: unknown[];
                        /** @description Condition must NOT match */
                        not?: unknown;
                        /** @description Find nodes with a specific type/tag */
                        hasType?: string | {
                            /** @description Type ID to search for */
                            typeId: string;
                            /** @description Include nodes with types that extend this type (default: true) */
                            includeExtensions?: boolean;
                        };
                        /** @description Match nodes by field values */
                        field?: {
                            /** @description Field/attribute ID to match */
                            fieldId: string;
                            /** @description Match field that references this specific node ID */
                            nodeId?: string;
                            /** @description Match field with this exact string value (case-insensitive) */
                            stringValue?: string;
                            /** @description Match field with this exact numeric value */
                            numberValue?: number;
                            /**
                             * @description Field presence state: defined/undefined/set/notSet
                             * @enum {unknown}
                             */
                            state?: "defined" | "undefined" | "set" | "notSet";
                        };
                        /** @description Compare field values */
                        compare?: {
                            /** @description Field/attribute ID to compare */
                            fieldId: string;
                            /**
                             * @description Comparison operator: gt (>), lt (<), eq (=)
                             * @enum {unknown}
                             */
                            operator: "gt" | "lt" | "eq";
                            /** @description Value to compare against */
                            value: string | number;
                            /**
                             * @description Type of comparison
                             * @enum {unknown}
                             */
                            type: "number" | "date" | "string";
                        };
                        /** @description Case-insensitive substring match in node names */
                        textContains?: string;
                        /** @description Regular expression pattern in /pattern/ or /pattern/i format */
                        textMatches?: string;
                        /** @description Find children of specified nodes */
                        childOf?: {
                            /** @description Parent node IDs */
                            nodeIds: string[];
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include referenced nodes (default: true) */
                            includeRefs?: boolean;
                        };
                        /** @description Find nodes owned by a specific node */
                        ownedBy?: {
                            /** @description Owner node ID */
                            nodeId: string;
                            /** @description Include all descendants (default: true) */
                            recursive?: boolean;
                            /** @description Include the owner node itself (default: false) */
                            includeSelf?: boolean;
                        };
                        /** @description Find nodes that link to these IDs */
                        linksTo?: string[];
                        /**
                         * @description Special node type filter
                         * @enum {unknown}
                         */
                        is?: "done" | "todo" | "template" | "field" | "published" | "entity" | "calendarNode" | "onDayNode" | "chat" | "search" | "command" | "inLibrary";
                        /**
                         * @description Find nodes that have specific content
                         * @enum {unknown}
                         */
                        has?: "tag" | "field" | "media" | "audio" | "video" | "image";
                        /** @description Find nodes created within N days */
                        created?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes edited within time range */
                        edited?: {
                            /**
                             * Format: email
                             * @description User email to filter by
                             */
                            by?: string;
                            /** @description Number of days */
                            last?: number;
                            /** @description Milliseconds timestamp */
                            since?: number;
                        };
                        /** @description Find nodes marked done within N days */
                        done?: {
                            /** @description Number of days */
                            last: number;
                        };
                        /** @description Find nodes with matching dates */
                        onDate?: string | {
                            /** @description ISO date string */
                            date: string;
                            /** @description Specific field to check */
                            fieldId?: string;
                            /** @description Check if date ranges overlap */
                            overlaps?: boolean;
                        };
                        /** @description Limit to specific workspace ID */
                        inWorkspace?: string;
                        /**
                         * @description Find tasks with due dates in the past
                         * @constant
                         */
                        overdue?: true;
                        /**
                         * @description Find nodes in the library/stash
                         * @constant
                         */
                        inLibrary?: true;
                    };
                    /** @description Find nodes with a specific type/tag */
                    hasType?: string | {
                        /** @description Type ID to search for */
                        typeId: string;
                        /** @description Include nodes with types that extend this type (default: true) */
                        includeExtensions?: boolean;
                    };
                    /** @description Match nodes by field values */
                    field?: {
                        /** @description Field/attribute ID to match */
                        fieldId: string;
                        /** @description Match field that references this specific node ID */
                        nodeId?: string;
                        /** @description Match field with this exact string value (case-insensitive) */
                        stringValue?: string;
                        /** @description Match field with this exact numeric value */
                        numberValue?: number;
                        /**
                         * @description Field presence state: defined/undefined/set/notSet
                         * @enum {unknown}
                         */
                        state?: "defined" | "undefined" | "set" | "notSet";
                    };
                    /** @description Compare field values */
                    compare?: {
                        /** @description Field/attribute ID to compare */
                        fieldId: string;
                        /**
                         * @description Comparison operator: gt (>), lt (<), eq (=)
                         * @enum {unknown}
                         */
                        operator: "gt" | "lt" | "eq";
                        /** @description Value to compare against */
                        value: string | number;
                        /**
                         * @description Type of comparison
                         * @enum {unknown}
                         */
                        type: "number" | "date" | "string";
                    };
                    /** @description Case-insensitive substring match in node names */
                    textContains?: string;
                    /** @description Regular expression pattern in /pattern/ or /pattern/i format */
                    textMatches?: string;
                    /** @description Find children of specified nodes */
                    childOf?: {
                        /** @description Parent node IDs */
                        nodeIds: string[];
                        /** @description Include all descendants (default: true) */
                        recursive?: boolean;
                        /** @description Include referenced nodes (default: true) */
                        includeRefs?: boolean;
                    };
                    /** @description Find nodes owned by a specific node */
                    ownedBy?: {
                        /** @description Owner node ID */
                        nodeId: string;
                        /** @description Include all descendants (default: true) */
                        recursive?: boolean;
                        /** @description Include the owner node itself (default: false) */
                        includeSelf?: boolean;
                    };
                    /** @description Find nodes that link to these IDs */
                    linksTo?: string[];
                    /**
                     * @description Special node type filter
                     * @enum {unknown}
                     */
                    is?: "done" | "todo" | "template" | "field" | "published" | "entity" | "calendarNode" | "onDayNode" | "chat" | "search" | "command" | "inLibrary";
                    /**
                     * @description Find nodes that have specific content
                     * @enum {unknown}
                     */
                    has?: "tag" | "field" | "media" | "audio" | "video" | "image";
                    /** @description Find nodes created within N days */
                    created?: {
                        /** @description Number of days */
                        last: number;
                    };
                    /** @description Find nodes edited within time range */
                    edited?: {
                        /**
                         * Format: email
                         * @description User email to filter by
                         */
                        by?: string;
                        /** @description Number of days */
                        last?: number;
                        /** @description Milliseconds timestamp */
                        since?: number;
                    };
                    /** @description Find nodes marked done within N days */
                    done?: {
                        /** @description Number of days */
                        last: number;
                    };
                    /** @description Find nodes with matching dates */
                    onDate?: string | {
                        /** @description ISO date string */
                        date: string;
                        /** @description Specific field to check */
                        fieldId?: string;
                        /** @description Check if date ranges overlap */
                        overlaps?: boolean;
                    };
                    /** @description Limit to specific workspace ID */
                    inWorkspace?: string;
                    /**
                     * @description Find tasks with due dates in the past
                     * @constant
                     */
                    overdue?: true;
                    /**
                     * @description Find nodes in the library/stash
                     * @constant
                     */
                    inLibrary?: true;
                };
                workspaceIds?: string[];
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        id: string;
                        name: string;
                        breadcrumb: string[];
                        tags: {
                            id: string;
                            name: string;
                        }[];
                        tagIds: string[];
                        workspaceId: string;
                        docType: string;
                        description?: string;
                        created: string;
                        inTrash: boolean;
                    }[];
                };
            };
        };
    };
    "nodes.read": {
        parameters: {
            query?: {
                maxDepth?: number;
            };
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        markdown: string;
                        /** @description Node name (empty string if unnamed) */
                        name?: string;
                        /** @description Node description (null if none) */
                        description?: string | null;
                    };
                };
            };
        };
    };
    "nodes.getChildren": {
        parameters: {
            query?: {
                limit?: number;
                offset?: number;
            };
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        children: {
                            id: string;
                            name: string;
                            tags: {
                                id: string;
                                name: string;
                            }[];
                            tagIds: string[];
                            childCount: number;
                            docType: string;
                            description?: string;
                            created: string;
                            inTrash: boolean;
                        }[];
                        total: number;
                        hasMore: boolean;
                    };
                };
            };
        };
    };
    "nodes.updateTags": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * @description Action to perform: add or remove tags
                     * @enum {unknown}
                     */
                    action: "add" | "remove";
                    /** @description Array of tag IDs to add/remove */
                    tagIds: string[];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        nodeName: string;
                        /** @enum {unknown} */
                        action: "add" | "remove";
                        results: {
                            tagId: string;
                            tagName: string;
                            success: boolean;
                            message: string;
                        }[];
                    };
                };
            };
        };
    };
    "nodes.setFieldOption": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The node id of the option value to set */
                    optionId: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        attributeId: string;
                        optionId: string;
                        optionName: string;
                        message: string;
                    };
                };
            };
        };
    };
    "nodes.setFieldContent": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                attributeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The string value to set for the field */
                    content: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        attributeId: string;
                        content: string;
                        message: string;
                    };
                };
            };
        };
    };
    "nodes.importTanaPaste": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                parentNodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Tana Paste formatted content to import */
                    content: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        parentNodeId: string;
                        targetNodeId: string;
                        createdNodes: {
                            id: string;
                            name: string;
                        }[];
                        message: string;
                    };
                };
            };
        };
    };
    "nodes.trash": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": Record<string, never>;
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        nodeName: string;
                        trashNodeId: string;
                        message: string;
                    };
                };
            };
        };
    };
    "nodes.setDone": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description true to check/mark done, false to uncheck */
                    done: boolean;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        nodeName: string;
                        done: boolean;
                        message: string;
                    };
                };
            };
        };
    };
    "nodes.update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description New name value (null to clear) */
                    name?: string | null;
                    /** @description New description (null to clear) */
                    description?: string | null;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        nodeId: string;
                        /** @description Updated name (if provided) */
                        name?: string | null;
                        /** @description Updated description (if provided) */
                        description?: string | null;
                        message: string;
                    };
                };
            };
        };
    };
    "tags.list": {
        parameters: {
            query?: {
                limit?: number;
            };
            header?: never;
            path: {
                workspaceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        id: string;
                        name: string;
                        color?: string;
                    }[];
                };
            };
        };
    };
    "tags.create": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                workspaceId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Name for the new tag */
                    name: string;
                    /** @description Description of the tag */
                    description?: string;
                    /**
                     * @description Tag IDs to extend from (inheritance)
                     * @default []
                     */
                    extendsTagIds?: string[];
                    /** @description Show a done checkbox on nodes with this tag */
                    showCheckbox?: boolean;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tagId: string;
                        tagName: string;
                        extendsTagNames?: string[];
                        message: string;
                    };
                };
            };
        };
    };
    "tags.getSchema": {
        parameters: {
            query?: {
                includeEditInstructions?: boolean;
            };
            header?: never;
            path: {
                tagId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        markdown: string;
                    };
                };
            };
        };
    };
    "tags.addField": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                tagId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Name for the new field */
                    name: string;
                    /** @description Description of the field */
                    description?: string;
                    /**
                     * @description Field data type: plain (any content), number, date, url, email, checkbox (boolean), user, instance (reference), options (selection)
                     * @enum {unknown}
                     */
                    dataType: "plain" | "number" | "date" | "url" | "email" | "checkbox" | "user" | "instance" | "options";
                    /** @description Required for instance type - the tag ID that instances reference */
                    sourceTagId?: string;
                    /** @description Options for options type fields */
                    options?: string[];
                    /** @description Default value for the field */
                    defaultValue?: string | boolean | number;
                    /**
                     * @description Whether the field can have multiple values
                     * @default false
                     */
                    isMultiValue?: boolean;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tagId: string;
                        tagName: string;
                        fieldId: string;
                        fieldName: string;
                        dataType: string;
                        message: string;
                    };
                };
            };
        };
    };
    "tags.setCheckbox": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                tagId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description Whether to show checkbox on nodes with this tag */
                    showCheckbox: boolean;
                    /** @description Optional mapping of checkbox state to field values */
                    doneStateMapping?: {
                        /** @description The options field ID to map checkbox state to */
                        fieldId: string;
                        /** @description Option IDs that represent "done" state */
                        checkedValues: string[];
                        /** @description Option IDs that represent "not done" state */
                        uncheckedValues?: string[];
                    };
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tagId: string;
                        tagName: string;
                        showCheckbox: boolean;
                        hasDoneStateMapping: boolean;
                        message: string;
                    };
                };
            };
        };
    };
    "calendar.getNodeId": {
        parameters: {
            query: {
                date?: string;
                granularity: "day" | "week" | "month" | "year";
            };
            header?: never;
            path: {
                workspaceId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The calendar node ID */
                        nodeId: string;
                    };
                };
            };
        };
    };
}
